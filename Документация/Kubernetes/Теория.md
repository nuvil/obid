Pavel, [29.06.2025 21:36]
# Вступление

kubernetes - это не орекстратор, а кластерная операционная система

node - это условный сервер предоставляет - тот сервер, который будет запускать ваше приложение в рамках кластера кубернетес
под - это абстракция кубернетес, которая нигде физически не существует, кроме внутренностей кубернетеса
У каждого пода свой набор сетевых интерфейсов, локалхост у контейнеров внутри пода общий 



Pod - это минимальная абстракция кубернетес с которой он умеет работать, под представляет 1 запущенное приложение, 1 его инстенс 
это минимально запущенное приложение,
внутри пода есть контейнер
внутри пода может быть несколько контейнеров, внутри каждого пода есть всегда минимум 2 контейнера
в докере запускается 2 контейнера, 1 nginx,  2-POD_NAMEPOD_HESH
кубернетес запускает под и создают pod, который создает сетевой namespace, с помощью этого контейнера создаем сеть в которую будут добавляться другие контейнеры
под - это минимальная единица в кубернетес, с контейнерами напрямую он не работает

в поде всегда лежит cri совместимый контейнер, все, что совместимо с контейнером тайм интерфейс, докер, крио, подман ...
кубер, как сущность не всегда управляет контейнером, вертлет - способ управление виртуальными машинами 

внутри себя кубер использует json
центральным компонентом кубернетес - это api server, мы всегда общаемся с кубернетес с помощью вызовов к его api, и всегда то что мы делаем происходит через api, api построен на REST
1 - версионируется apiVersion: v1, deployment находится в aps/v 1 - сделано для того, чтобы когда выходила новая версия кубера, разрабам нужно внести изменение в абстракцию под, вместо того, чтобы не ломать совместимость, в  новой версии будет существовать v1, а не beta v1 сразу же 
2 - kind: Pod - тип описанного объекта (Secret, service и т.д.) 
3 - metadata:
    name: my-pod
4 - spec:
  conteiners:
  - image: образ
  name: nginx
  ports:
  - containerPort: 80 - способ документирования
k create -f pod.yamlk - создание пода
k describe po pod_name


чем список от словаря в yaml дойти до анхоров
# ReplicaSet

replicaset - это такой объект, который предоставляет из себя набор реплик приложения 
Внутри replicaset содержится тимплейт именно как тимплейт описание подов, который создает наши replicaset. Replicaset создавая из teamplate поды будет на каждый под расставлять lables (ярлыки), у самого replicaset есть информация о selectar - его поды, где у подов есть app: myapp, есть поле n replic - сколько создать реплик                                                        
kubectl scale --replicas 3 replicaset file_name - для увеличения количества реплик, скелить можно вверх или вниз, кубер будет смотреть на самый молодой под

kubectl set image replicaset my-replicaset nginx=1.13 - обновление образа
kubectl set image replicaset my-replicaset '*=image_name' - если контейнер 1
Чтобы поменять образ - нужно под пересоздать
replicaset никак не помогает обновлять приложение 

kubectl explaing pod - показать документацию - показать все поля пода верхнеуровненно 
# Deployment 

Описание в spec точно такое же, как у репликасета, описание точно такое же, как у replicaset
отличается ничем, кроме поведения
отличие в имени от replicaset - это два хеша, первый хеш одинаковый, второй разный 
deployment создал replicaset, а он создал поды
обновить в deployment:
1) Идем в файлик деплоймент, меняем образ - применяем 
2) kubectl set image deployment name_deployment '*=image_name'
3) kubectl edit - отредактировать ресурс в кубернетес на лету и можно редактировать объект
4) kubectl edit deployment deployment_name - редактируем деплоймент внутри кубернетес в редакторе по умолчанию 
старые поды удаляются, два новых пода имеет новый образ и новый репликасеты (в названии хеш) 

Почему кубер не удалил старый репликасеты
В kubectl есть команда kubectl rollout undo deployment my-deployment
Они не удаляются, если нужно откатиться (undo)

чтобы посмотреть ревизию - kubect rollout history deplyment my-deployment

Есть два метода отката - recreate и rollingUpdate
у rollingUpdate можно настроить:
maxSurge (параметр) - говорит о том на сколько в количестве подов или в проценте можно поднять количество подов в rollingUpdate относительно того, сколько указано replicaset, т.е. указано 2 реплик, а maxSurge указано 1 (10%) (по умолчанию), значит в момент rollingUpdate запустить сразу 3 реплики, значит запустить сразу 1 новую реплику
maxUnavailable - говорит о том  на сколько мы можем количество реплик нашего приложения опустить, относительно их дефолтного состояния, т.е. если у нас параметр maxUnavailable при 2 репликах равняется 1 (10%) (дефолтное значение) - то это говорит о том, что при rollingUpdate можно 1 старую удалить

что бы скорректировать maxSurge maxUnavailable, нужно указать maxSurge: 1, maxUnavailable: 0, чтобы не было downtime, если реплик 100, то указываем в процентах (25%, 25%)

Namespace - это пространство имен, мы можем разделить наш кластер на отдельные пространство имен, в рамках 1 нейсмейса нельзя создать одинаковые объекта с одним и тем же именем 
Есть ресурсы бывают namespace'ные :
pod, deployment, PVC, configmap, service, ingress
Есть кластерные ресурсы:
PV
StorageClass
ClusterRole
и т.д.

Ресурсы в kubernetes, берут cpu и memory
Limits: это то количество ресурсов, которые контейнер(под) может использовать, допустим 
2 cpu или 2 memory
Есть auth memory killer (omk) в ядре linux, если приложение будет использовать больше памяти, то он его убьет и deployment его пересоздаст  

Requests: это количество ресурсов, которые резервируется для подов на ноде, не деляться с другими подами на ноде, это не физическая величина, они нигде, кроме как в yaml файле не существует в описании пода, на основании ресурсов назначает, на какую ноду поставить pod,

Как работает:
У нас есть node, у ноды есть копасити (ёмкость), у неё есть копасити по памяти и ядрам cpu, 16/16, если мы создадим под с указанием реквеста 8 ядер и он приедет на 1 из нод, то свободная емкасть ресурса от cpu на ноде станет 8, если приедет ещё один под с реквестом 8, то больше на эту ноду поды с реквестами попадать не будут, кубер принимает решения, как поды с их ресурами распределять на кластере, реквесты никакого решения не имеют к реальному потребления ресурсов подами, ему без разницы сколько будет есть, ему главное определить где он будет на ноде

QoS Class - относятся к limit и reuest и к их сочетанию
Qos Class в кубернетес бывают 3 штуки
1)  BestEffort - лучшие приложение (не ставим лимитов), но если ресурсов будет не хватать, то по-первых получим столько ресурсов, сколько свободно, а во вторых, как кубер будет эвукуировать поды, и если есть besteffot, то он их удалит, чтобы другие работали на ноде
2) Burstable - если указаны request, но не указаны limit, либо указано то и то, но лимиты больше, чем request, они удаляться будут во втором случае в ноде (перераспредяться по ноде)
3) garantit - все параметры равны, высшие qos class, трогать не будет и будет стараться их сохранить

kubectl patch - пропатчить pod

если пендинг - то не может назначить под ни на какую ноду ()

![[Pasted image 20250630174227.png]]