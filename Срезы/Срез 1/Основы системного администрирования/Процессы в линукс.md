## Первый блок
1. Что такое PID? 

PID (Process ID) — это уникальный числовой идентификатор, присваиваемый каждому процессу в Linux/Unix при его запуске. Он используется системой для управления процессами (например, для их завершения, приоритезации и отслеживания).

2. Чем процесс отличается от потока?

- Процесс:

  - Изолированное окружение с собственными ресурсами (память, файловые дескрипторы).

  - Создается через `fork()`.

  - Обмен данными между процессами требует IPC (межпроцессного взаимодействия: pipes, sockets и т.д.).

- Поток (Thread):

  - Часть процесса, разделяет с ним ресурсы (память, файлы).

  - Создается через `pthread_create()`.

  - Легче и быстрее создается, чем процесс.

3. Сигналы управления процессами

Основные сигналы:

- SIGTERM (15) — запрос корректного завершения процесса. 

- SIGKILL (9) — принудительное завершение (нельзя перехватить). 

- SIGINT (2) — прерывание с клавиатуры (Ctrl+C). 

- SIGHUP (1) — сигнал "перезагрузки" (часто используется для перечитывания конфигов). 

- SIGSTOP (19) — приостановка процесса. 

- SIGCONT (18) — возобновление приостановленного процесса. 

4. Как посмотреть переменные среды в текущей сессии? 

Используйте команды:

printenv    # Вывести все переменные

env         # Тоже вывод всех переменных

echo $VAR   # Проверить конкретную переменную (например, echo $PATH)

5. Как добавить переменную среды в текущей сессии? 

export VAR_NAME="value"   # Пример: export MY_VAR="Hello"

Переменная будет доступна только в текущей сессии и её дочерних процессах.

6. Как удалить переменную среды в текущей сессии?

unset VAR_NAME   # Пример: unset MY_VAR

7. Система инициализации в Linux

Это первый процесс (`PID=1`), который запускается при старте системы и управляет всеми остальными процессами. 

Основные системы инициализации:

- SysVinit — классическая система с скриптами в `/etc/init.d/`.

- systemd — современная система, использует юниты (`.service`, `.target`).

- Upstart (устаревший) — был в Ubuntu до версии 15.04.

8. Управление сервисами в systemd 

Основные команды:

systemctl start service_name    # Запустить сервис

systemctl stop service_name     # Остановить

systemctl restart service_name  # Перезапустить

systemctl reload service_name   # Перезагрузить конфиги без остановки

systemctl enable service_name   # Включить автозагрузку

systemctl disable service_name  # Отключить автозагрузку

systemctl status service_name   # Проверить статус

9. Просмотр логов systemd сервиса 

Используйте `journalctl`:

journalctl -u service_name      # Логи конкретного сервиса

journalctl -u service_name -f   # Вывод в реальном времени (follow)

journalctl -u service_name --since "2024-01-01" --until "2024-01-02"  # Логи за период
## Второй блок
1. Чем SIGTERM отличается от SIGKILL?

SIGTERM (сигнал 15) — это «вежливый» сигнал завершения процесса. Он позволяет процессу корректно завершить свою работу (закрыть файлы, сохранить данные, остановить дочерние процессы). 

SIGKILL (сигнал 9) — принудительное немедленное завершение процесса. Процесс не может его обработать или проигнорировать. Используется, когда SIGTERM не срабатывает. 

Разница: SIGTERM дает шанс на корректное завершение, SIGKILL убивает процесс без возможности обработки.

2. Что содержится в директории `/proc`?

Это виртуальная файловая система, содержащая информацию о ядре и запущенных процессах. Основные элементы:

- Папки с PID (например, `/proc/1234`) — информация о процессе с ID 1234.

  - Файлы внутри: `cmdline` (команда запуска), `status` (статус процесса), `exe` (ссылка на исполняемый файл), `environ` (переменные среды процесса).

- Системная информация:

  - `/proc/cpuinfo` — данные о CPU.

  - `/proc/meminfo` — информация о памяти.

  - `/proc/filesystems` — поддерживаемые файловые системы.

  - `/proc/modules` — загруженные модули ядра.

3. Отличия между добавлением переменной среды с помощью `export` и без него?

- Без `export` (например, `VAR=value`): 

  Переменная доступна только в текущей оболочке. Дочерние процессы (например, запущенные скрипты) её не увидят.

- С `export` (например, `export VAR=value`): 

  Переменная становится **глобальной** для текущей сессии и наследуется всеми дочерними процессами.

Пример:

VAR=hello    # Только для текущей оболочки

export VAR=world  # Доступна для дочерних процессов

4. Как создать systemd сервис для произвольного приложения?

5. Создайте файл сервиса в `/etc/systemd/system/`, например: 

   sudo nano /etc/systemd/system/myapp.service

6. Добавьте конфигурацию (пример):

   ```ini

   [Unit]

   Description=My Custom Application

   After=network.target

   [Service]

   Type=simple

   User=myuser

   WorkingDirectory=/path/to/app

   ExecStart=/path/to/app/executable

   Restart=on-failure

   [Install]

   WantedBy=multi-user.target

   ```

   - `Type=simple` — для обычных приложений.

   - `Restart=on-failure` — перезапуск при сбое.

   - Укажите пользователя (`User`), рабочую директорию (`WorkingDirectory`) и переменные среды (`Environment=KEY=value`), если нужно.

3. Обновите systemd и запустите сервис:

   ```bash

   sudo systemctl daemon-reload

   sudo systemctl start myapp

   sudo systemctl enable myapp  # Для автозапуска при загрузке

   ```

**Проверка статуса**: 

```bash

systemctl status myapp

```
## Третий блок
### Состояния процессов в Linux:

В Linux процессы могут находиться в следующих основных состояниях:

1. **Running (R)** 

   Процесс выполняется в данный момент или находится в очереди планировщика (готов к выполнению).

2. **Interruptible Sleep (S)** 

   Процесс ожидает события (например, завершения ввода-вывода или сигнала). Может быть прерван.

3. **Uninterruptible Sleep (D)** 

   Процесс ожидает завершения операции ввода-вывода (например, работы с диском). **Не может** быть прерван даже сигналами.

4. **Stopped (T)** 

   Процесс остановлен сигналом (например, `SIGSTOP`, `SIGTSTP`) или отладчиком. Может быть возобновлён сигналом `SIGCONT`.

5. **Zombie (Z)** 

   Процесс завершился, но его запись остаётся в таблице процессов, пока родительский процесс не прочитает его статус (через `wait()`).

6. **Dead (X)** 

   Процесс полностью завершён (встречается редко, так как состояние временное перед удалением из таблицы процессов).

---

### Как посмотреть переменные среды процесса по его PID:

Информация о переменных окружения процесса хранится в файле `/proc/<PID>/environ`. Для просмотра:

#### Способ 1: Через `cat` и `tr`

```bash

cat /proc/<PID>/environ | tr '\0' '\n'

```

- `tr '\0' '\n'` заменяет нулевые символы на переносы строк для удобного отображения.

#### Способ 2: Использование `strings`

```bash

strings /proc/<PID>/environ

```

#### Способ 3: Через `ps`

```bash

ps e -p <PID> -ww

```

- `e` — отобразить переменные окружения.

- `-ww` — отключить обрезку строк (показывает полный вывод).

---

**Пример:** 

Для процесса с PID `1234`:

```bash

cat /proc/1234/environ | tr '\0' '\n'

```

**Примечание:** 

Для доступа к `/proc/<PID>/environ` требуются права суперпользователя, если процесс принадлежит другому пользователю.