## Первый блок
1. **Локальный и удалённый репозитории**

·         **Локальный репозиторий** — хранится на вашем компьютере. Содержит всю историю изменений, ветки и файлы проекта.

·         **Удалённый репозиторий** — хранится на сервере (например, GitHub, GitLab). Используется для совместной работы и синхронизации кода.

---

2. **Создать локальный репозиторий**

git init

(в папке проекта) — создаст скрытую папку .git, где будет храниться история.

---

3. **Создать удалённый репозиторий**

1.    Зарегистрируйтесь на GitHub/GitLab.

2.    Нажмите «New repository».

3.    Укажите имя и настройки → «Create repository».

4.    Получите URL репозитория (например, https://github.com/username/repo.git).

---

4. **Управление удалённым репозиторием**

·         **Добавить**:

git remote add origin https://github.com/username/repo.git

·         **Удалить**:

git remote remove origin

·         **Изменить URL**:

git remote set-url origin новый_адрес.git

---

5. **Скачать код из удалённого репозитория**

·         **Клонировать репозиторий**:

git clone https://github.com/username/repo.git

·         **Обновить локальную копию** (если репозиторий уже склонирован):

git pull origin main

---

6. **Зафиксировать изменения**

1.    Добавить файлы в «индекс»:

git add файл.txt  # или git add . (все изменения)

2.    Создать коммит:

git commit -m "Описание изменений"

---

7. **Отправить код в удалённый репозиторий**

git push origin main  # отправить ветку main в origin

---

8. **Создать новую ветку**

git branch новая_ветка  # создать ветку

git checkout новая_ветка  # переключиться на неё

### Или одной командой:

git checkout -b новая_ветка

---

9. **Перейти на другую ветку**

git checkout имя_ветки

### Или (в новых версиях Git):

git switch имя_ветки

---

10. **Файл** .gitignore

·         Это файл, в котором перечислены файлы/папки, игнорируемые Git (например, временные файлы, логи).

·         Пример содержимого:

*.log

node_modules/

.env

---

11. **Просмотр истории коммитов**

git log  # полная история

git log --oneline  # краткий вывод

git log --graph  # визуализация веток
## Второй блок
1. **Отличие** git reset **от** git revert

·         git reset:

o    Перемещает указатель текущей ветки на другой коммит (может удалить историю).

o    Используется для отмены локальных изменений или изменения истории (опасно для опубликованных коммитов).

o    Режимы: --soft (сохраняет изменения в индексе), --mixed (по умолчанию, сбрасывает индекс), --hard (полное удаление изменений).

·         git revert:

o    Создает **новый коммит**, отменяющий изменения указанного коммита.

o    Безопасен для публичной истории, так как не перезаписывает её.

---

2. **Git vs GitHub/GitLab/BitBucket**

·         **Git** — распределенная система контроля версий (работает локально).

·         **GitHub/GitLab/BitBucket** — облачные платформы для хостинга Git-репозиториев с дополнительными инструментами: Pull Requests, Issues, CI/CD, визуализация.

---

3. **Подтянуть новые ветки без слияния**

·         Выполните git fetch — обновляет информацию об удалённых ветках.

·         Создайте локальную ветку, отслеживающую удалённую:

git checkout -b <новая-ветка> origin/<удалённая-ветка>

или

git switch --track origin/<удалённая-ветка>

---

4. **Режимы** git reset

1.    --soft:

o    Сбрасывает HEAD на указанный коммит, сохраняя изменения в индексе.

2.    --mixed (по умолчанию):

o    Сбрасывает HEAD и индекс, но сохраняет изменения в рабочей директории.

3.    --hard:

o    Полностью удаляет все изменения — и в индексе, и в рабочей директории.

---

5. **Squash коммитов**

Объединение нескольких коммитов в один. Используется для упрощения истории. Примеры:

·         При интерактивном rebase: git rebase -i HEAD~3 → заменить pick на squash.

·         При слиянии: git merge --squash feature.

---

6. **Перенос коммитов между ветками**

·         git cherry-pick <хэш> — копирует конкретный коммит в текущую ветку.

·         git merge — объединяет всю историю ветки.

·         git rebase — перезаписывает историю, перенося коммиты текущей ветки на верх целевой.

---

7. git merge **vs** git rebase

·         **Merge**:

o    Создает коммит слияния, сохраняя историю ветвления.

o    Подходит для публичных веток (не перезаписывает историю).

·         **Rebase**:

o    "Перемещает" коммиты текущей ветки на верх другой, делая историю линейной.

o    Изменяет хэши коммитов → не рекомендуется для общих веток.

---

8. .gitattributes

Файл для настройки атрибутов файлов в репозитории. Примеры использования:

·         Указание типа файла: *.psd binary (обрабатывать как бинарный).

·         Настройка слияния: *.json merge=union (объединять конфликты автоматически).

·         Контроль концов строк: * text=auto (автоматически конвертировать CRLF).

---

9. **Сравнение файла между ветками**

git diff <ветка**1**> <ветка**2**> -- <путь/к/файлу>

Пример:

git diff main feature -- src/app.js
## Третий блок

1. **Что такое interactive rebase, чем отличается от обычного?**

**Interactive rebase** — это инструмент Git для изменения истории коммитов. Он позволяет:

·         Объединять, переименовывать, удалять или изменять порядок коммитов.

·         Исправлять сообщения коммитов.

·         Разбивать коммиты на части.

**Отличие от обычного rebase**:

·         Обычный git rebase просто переносит коммиты из одной ветки в другую, сохраняя их содержимое.

·         Interactive rebase даёт **контроль над каждым коммитом** в процессе перезаписи истории.

**Когда использовать**:

·         Локальная очистка истории перед пул-реквестом.

·         Исправление старых коммитов (например, удаление секретов из истории).

---

2. **В каких случаях нужен git cherry-pick?**

git cherry-pick копирует изменения из **конкретного коммита** в текущую ветку. Примеры использования:

·         Перенос исправления бага из main в старую версию (например, release-2.0).

·         Восстановление потерянного коммита из другой ветки.

·         Избирательное применение изменений без слияния всей ветки.

**Осторожно**:

·         Может вызвать конфликты.

·         Не злоупотребляйте — это признак плохой структуры веток, если используется часто.

---

3. **Проблема при работе между Linux/Mac и Windows**

**Проблема**: Разные символы перевода строки:

·         Windows: CRLF (\r\n).

·         Linux/Mac: LF (\n).

**Последствия**:

·         Git видит изменения в окончаниях строк как реальные изменения, что вызывает ложные конфликты.

**Решение**:

·         Настроить .gitattributes:

* text=auto

*.sh text eol=lf

*.bat text eol=crlf

·         Глобальные настройки Git:

git config --global core.autocrlf input  # Linux/Mac

git config --global core.autocrlf true   # Windows

---

4. **Стратегии ветвления**

Основные стратегии:

|**Стратегия**|**Особенности**|**Подходит для**|
|---|---|---|
|**Git Flow**|Долгоживущие ветки (main, develop, release, hotfix).|Проектов с фиксированными релизами.|
|**GitHub Flow**|Одна ветка main, короткоживущие feature-ветки, CI/CD.|Непрерывного деплоя (веб-приложения).|
|**GitLab Flow**|Ветки по окружениям (production, staging).|Проектов с тестированием в нескольких средах.|
|**Trunk-Based**|Минимум веток, частые коммиты в main.|Маленьких команд и микросервисов.|

**Отличия**:

·         Сложность: Git Flow > GitLab Flow > GitHub Flow > Trunk-Based.

·         Гибкость: Trunk-Based проще для CI/CD, Git Flow — для строгого контроля версий.

---

5. **Как выбрать стратегию ветвления?**

·         **Размер команды**:

o    Маленькие команды → Trunk-Based или GitHub Flow.

o    Крупные → Git Flow или GitLab Flow.

·         **Частота релизов**:

o    Ежедневные деплои → Trunk-Based.

o    Редкие версии → Git Flow.

·         **Специфика проекта**:

o    Монолиты → Git Flow.

o    Микросервисы/веб-приложения → GitHub Flow.

·         **Инфраструктура**:

o    Наличие тестовых окружений → GitLab Flow.

**Совет**: Начните с простой стратегии (например, GitHub Flow) и адаптируйте под нужды команды.

---

**Итог**: Выбор инструментов и стратегий зависит от контекста проекта. Главное — договориться о едином подходе в команде и документировать его.