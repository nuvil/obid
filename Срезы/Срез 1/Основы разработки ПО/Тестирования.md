## Первый блок

Тесты можно классифицировать по различным критериям, включая цели, методы выполнения, этапы разработки и области применения. Вот основные категории:

---

**1. По целям тестирования**

·         **Функциональное тестирование**  
Проверяет соответствие системы функциональным требованиям (например, юнит-тесты, сценарии использования).

·         **Нефункциональное тестирование**  
Оценивает характеристики, не связанные с прямой функциональностью:

o    _Производительность_ (нагрузочное, стресс-тестирование).

o    _Безопасность_ (проверка уязвимостей).

o    _Юзабилити_ (удобство интерфейса).

o    _Надежность_ (устойчивость к сбоям).

·         **Тестирование изменений**

o    _Регрессионное_ (проверка, что изменения не сломали существующий функционал).

o    _Дымовое_ (быстрая проверка базовой работоспособности после внесения правок).

---

**2. По уровню детализации (уровни тестирования)**

·         **Модульное (Unit-тестирование)**  
Тестирование отдельных компонентов (функций, классов) в изоляции.

·         **Интеграционное**  
Проверка взаимодействия между модулями или системами.

·         **Системное**  
Тестирование системы в целом на соответствие требованиям.

·         **Приемочное (Acceptance Testing)**  
Финалная проверка заказчиком перед сдачей проекта (UAT — User Acceptance Testing).

---

**3. По степени автоматизации**

·         **Ручное тестирование**  
Выполняется вручную (например, исследовательское тестирование, проверка UI).

·         **Автоматизированное**  
Использование скриптов и инструментов (например, Selenium для веб-приложений).

·         **Полуавтоматизированное**  
Комбинация ручных и автоматических этапов.

---

**4. По времени выполнения**

·         **Статическое тестирование**  
Анализ кода и документации без запуска программы (например, код-ревью, проверка требований).

·         **Динамическое тестирование**  
Тестирование работающей системы (большинство видов тестов).

---

**5. По доступу к коду и внутренней структуре**

·         **Чёрный ящик**  
Тестирование без знания внутренней реализации (фокус на ввод/вывод).

·         **Белый ящик**  
Тестирование с доступом к коду и внутренней логике (покрытие условий, ветвей).

·         **Серый ящик**  
Комбинация двух подходов (частичное знание внутренней структуры).

---

**6. По объёму данных и сценариев**

·         **Позитивное тестирование**  
Проверка корректных сценариев (валидные данные).

·         **Негативное тестирование**  
Проверка обработки ошибок (невалидные данные, исключительные ситуации).

·         **Тестирование граничных значений**  
Анализ поведения на краях допустимых диапазонов.

---

**7. Специфические виды тестирования**

·         **Нагрузочное (Performance Testing)**  
Проверка системы под высокой нагрузкой.

·         **Стресс-тестирование**  
Работа в экстремальных условиях (например, нехватка ресурсов).

·         **A/B-тестирование**  
Сравнение двух версий продукта для выбора оптимальной.

·         **Конфигурационное**  
Проверка работы на разных ОС, браузерах, устройствах.

·         **Тестирование совместимости**  
Взаимодействие с другими системами или API.

·         **Тестирование безопасности**  
Поиск уязвимостей (например, SQL-инъекции, XSS).

---

**8. По области применения вне IT**

·         **Психологические тесты**  
Оценка личности, интеллекта, эмоционального состояния.

·         **Педагогические тесты**  
Проверка знаний учащихся (например, экзамены, опросники).

·         **Медицинские тесты**  
Диагностика заболеваний (лабораторные анализы, функциональные пробы).

---

**9. По степени изолированности**

·         **Изолированное (модульное)**  
Тестирование компонента без зависимостей.

·         **Сквозное (End-to-End, E2E)**  
Проверка всего потока работы системы от начала до конца.

---

**10. По этапу разработки**

·         **Альфа-тестирование**  
Внутреннее тестирование на ранних стадиях.

·         **Бета-тестирование**  
Тестирование с привлечением реальных пользователей перед релизом.

---

Эти классификации часто пересекаются. Например, **автоматизированное регрессионное тестирование** может быть частью **функционального** и выполняться на **системном** уровне. Выбор методов зависит от целей проекта, ресурсов и рисков.
## Второй блок
Чем Unit-тесты отличаются от интеграционных?

1.    **Unit-тесты (модульные тесты):**

o    **Цель:** Проверяют работу _отдельных компонентов_ (функций, методов, классов) **изолированно** от других частей системы.

o    **Изоляция:** Используются моки (mock), стабы (stub) или заглушки для замены внешних зависимостей (например, баз данных, API).

o    **Скорость:** Выполняются очень быстро, так как тестируют небольшие фрагменты кода.

o    **Пример:** Проверка функции, которая складывает два числа, без обращения к другим модулям.

2.    **Интеграционные тесты:**

o    **Цель:** Проверяют взаимодействие _между компонентами_ (модулями, сервисами, системами) или с внешними ресурсами (БД, API).

o    **Реальные зависимости:** Часто используют реальные базы данных, сети или внешние сервисы (либо их эмуляторы).

o    **Обнаружение проблем:** Выявляют ошибки интеграции: несовместимость интерфейсов, некорректные данные, проблемы с сетью.

o    **Пример:** Проверка работы API, который сохраняет данные в БД и взаимодействует с другим микросервисом.

---

Что такое автоматизированное тестирование?

Это **процесс выполнения тестов с помощью инструментов и скриптов**, без ручного вмешательства. Тесты запускаются программно, а их результаты автоматически сравниваются с ожидаемыми.  
**Примеры инструментов:** pytest, JUnit, Selenium, Postman (для автоматизации API-тестов).

---

Чем автоматизированное тестирование отличается от классических Unit и интеграционных тестов?

·         **Unit и интеграционные тесты** — это **категории тестов**, определяющие уровень детализации:

o    Unit — тестирование изолированных компонентов.

o    Интеграционные — тестирование взаимодействий.

·         **Автоматизированное тестирование** — это **способ выполнения тестов** (автоматически, а не вручную). Оно может включать:

o    Unit-тесты.

o    Интеграционные тесты.

o    End-to-end (E2E) тесты (проверка всего приложения от начала до конца).

o    Нагрузочные тесты.

**Ключевые отличия:**

|**Критерий**|**Unit-тесты**|**Интеграционные тесты**|**Автоматизированное тестирование**|
|---|---|---|---|
|**Уровень**|Изолированный|Взаимодействие модулей|Способ выполнения (все уровни тестов)|
|**Зависимости**|Заглушки|Реальные/эмуляторы|Зависит от типа теста|
|**Скорость**|Очень быстрые|Медленнее unit-тестов|Зависит от типа теста|
|**Пример**|Проверка функции|Проверка API + БД|Любой тест, запущенный через скрипт|

---

Примеры:

1.    **Unit-тест (автоматизированный):**

def test_add():

    assert add(2, 3) == 5  # Проверка функции сложения

2.    **Интеграционный тест (автоматизированный):**

def test_user_creation():

    user = create_user("test@example.com")  # Вызов API

    assert user_in_database(user.id)  # Проверка записи в БД

3.    **Ручное тестирование:** Тестировщик вручную проверяет интерфейс приложения.

Таким образом, Unit и интеграционные тесты могут быть частью автоматизированного тестирования, но автоматизация охватывает и другие виды тестов.
## Третий блок
**Нагрузочное тестирование** — это метод проверки производительности системы, приложения или сервиса под определённой нагрузкой. Его цель — оценить, как система ведёт себя при пиковом количестве пользователей, транзакций или запросов, а также выявить узкие места, которые могут привести к замедлению работы или сбоям.

---

**Зачем нужно нагрузочное тестирование?**

1.    **Определение производительности**: Проверка времени отклика, пропускной способности и стабильности.

2.    **Выявление узких мест**: Поиск проблем в коде, конфигурации серверов, базе данных или сети.

3.    **Проверка масштабируемости**: Оценка способности системы работать при увеличении нагрузки.

4.    **Подготовка к пиковым нагрузкам**: Например, к Black Friday для интернет-магазина или запуску новой функции.

---

**Как проводить нагрузочное тестирование?**

**1. Планирование**

·         **Определите цели**: Какие метрики важны (время отклика, количество ошибок, нагрузка на CPU/RAM)?

·         **Выберите сценарии**: Какие функции или запросы будут тестироваться (например, авторизация, оплата, поиск)?

·         **Установите параметры нагрузки**: Сколько пользователей/запросов в секунду? Как долго будет длиться тест?

**2. Выбор инструментов**

Популярные инструменты:

·         **JMeter**: Бесплатный, с графическим интерфейсом, подходит для веб-приложений.

·         **Gatling**: Основан на Scala, удобен для сценариев с высокой нагрузкой.

·         **Locust**: Пишите тесты на Python, распределённая нагрузка.

·         **k6**: Инструмент для DevOps, интеграция с CI/CD.

·         **Cloud-решения**: BlazeMeter, LoadRunner Cloud.

**3. Настройка тестовой среды**

·         Воспроизведите среду, максимально близкую к продакшену (аналогичные серверы, БД, сеть).

·         Убедитесь, что мониторинг настроен: сбор данных о CPU, памяти, дисках, запросах к БД.

**4. Создание тестовых сценариев**

·         Смоделируйте поведение пользователей: последовательность действий (например, вход → поиск → добавление в корзину → оплата).

·         Укажите параметры: задержки между запросами, динамические данные (например, токены авторизации).

**5. Запуск теста**

·         Начните с малой нагрузки и постепенно увеличивайте её (например, от 100 до 10 000 пользователей).

·         Проводите тесты разных типов:

o    **Нагрузочное тестирование** — проверка под ожидаемой нагрузкой.

o    **Стресс-тестирование** — превышение предельных значений для поиска точки отказа.

o    **Объёмное тестирование** — работа с большими объёмами данных (например, миллионы записей в БД).

o    **Пиковое тестирование** — резкое увеличение нагрузки на короткое время.

**6. Мониторинг и сбор данных**

·         Отслеживайте метрики в реальном времени:

o    Время отклика системы.

o    Количество ошибок (HTTP 500, таймауты).

o    Использование ресурсов серверов (CPU, RAM, диск).

o    Производительность БД (запросы в секунду, блокировки).

**7. Анализ результатов**

·         Выявите узкие места: медленные запросы, ошибки под нагрузкой, утечки памяти.

·         Сравните результаты с целевыми метриками (например, время отклика не должно превышать 2 сек).

·         Составьте отчёт с рекомендациями по оптимизации (например, настройка индексов БД, кэширование, масштабирование серверов).

---

**Пример: Тестирование веб-приложения с JMeter**

1.    Создайте тестовый план: добавьте поток (Thread Group) с числом виртуальных пользователей.

2.    Настройте HTTP-запросы: укажите эндпоинты (например, /api/login).

3.    Добавьте таймеры для имитации реального поведения пользователей.

4.    Запустите тест и используйте графики и отчёты JMeter для анализа (например, Aggregate Report).

5.    Исправьте найденные проблемы (например, оптимизируйте медленный SQL-запрос).

---

**Рекомендации**

·         **Автоматизируйте тесты**: Интегрируйте в CI/CD, чтобы запускать их при каждом обновлении кода.

·         **Тестируйте постепенно**: Начните с одного модуля, затем переходите к комплексным сценариям.

·         **Повторяйте тесты**: После оптимизации системы убедитесь, что изменения дали результат.

·         **Не игнорируйте «реальные» данные**: Используйте актуальные данные из продакшена (например, размер БД).

---

**Ошибки, которых стоит избегать**:

·         Тестирование в среде, не идентичной продакшену.

·         Недостаточная длительность теста (например, 5 минут вместо часа).

·         Игнорирование мониторинга ресурсов сервера и БД.

·         Проверка только «идеальных» сценариев без учёта пиковых нагрузок.

Нагрузочное тестирование — это не разовая задача, а часть процесса разработки и поддержки стабильной работы системы.