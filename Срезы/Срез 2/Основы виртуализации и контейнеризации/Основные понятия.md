## Первый блок
Что такое виртуализация? Что такое контейнеризация?
**Виртуализация** — это технология, которая позволяет создавать виртуальные (а не физические) версии вычислительных ресурсов, таких как серверы, хранилища, сети и даже операционные системы.

**Контейнеризация** — это форма виртуализации на уровне ОС, при которой приложения запускаются в изолированных пользовательских пространствах (**контейнерах**), использующих общее ядро хостовой системы.

---
## Второй блок
В чём отличия между виртуализацией и контейнеризацией?  

| Характеристика           | Виртуализация                                   | Контейнеризация                                      |
| ------------------------ | ----------------------------------------------- | ---------------------------------------------------- |
| Изоляция                 | Полная (на уровне аппаратного обеспечения)      | На уровне операционной системы (процессы)            |
| **Операционная система** | Каждая ВМ имеет собственную ОС                  | Общая ОС хост-машины                                 |
| Ядро                     | Каждая ВМ имеет собственное ядро                | Общее ядро хост-машины                               |
| Ресурсы                  | Высокое потребление ресурсов                    | Низкое потребление ресурсов                          |
| **Размер образа**        | Большие образы (включая ОС)                     | Маленькие образы (только приложение и зависимости)   |
| **Скорость запуска**     | Медленная                                       | Быстрая                                              |
| Плотность                | Низкая (меньше ВМ на одном сервере)             | Высокая (больше контейнеров на одном сервере)        |
| **Управление**           | Гипервизоры (VMware, Hyper-V, VirtualBox и др.) | Платформы контейнеризации (Docker, Kubernetes и др.) |
| Применение               | Разные ОС, эмуляция систем                      | Микросервисы, масштабирование приложений             |

В чем преимущества и недостатки каждого из подходов?

- **Виртуализация**
**Преимущества:**  
✅ Полная изоляция (каждая ВМ — как отдельный сервер)
✅ Поддержка разных ОС на одном железе
✅ Хорошая безопасность (из-за изоляции на уровне ядра)
✅ Подходит для legacy-приложений, требующих специфичного окружения
**Недостатки:**  
❌ Большие накладные расходы (каждая ВМ требует своей ОС)
❌ Медленный запуск (несколько секунд/минут)
❌ Больший расход ресурсов (CPU, RAM, диска)

- **Контейнеризация**
**Преимущества:**  
✅ Минимальные накладные расходы (нет гостевой ОС)
✅ Быстрый запуск (миллисекунды)
✅ Экономия ресурсов (можно запускать больше сервисов на том же железе)
✅ Простота масштабирования (оркестрация через Kubernetes, Docker Swarm)

**Недостатки:**  
❌ Меньшая изоляция (все контейнеры используют одно ядро ОС)
❌ Ограниченная поддержка разных ОС (Linux-контейнеры не запустятся на Windows без эмуляции)
❌ Потенциальные проблемы с безопасностью (если сломано ядро — уязвимы все контейнеры)
## Третий блок

На каких механизмах основана работа контейнеризации в Linux? 
Контейнеризация в Linux основана на нескольких ключевых механизмах ядра:
1.    **Namespaces** – изолируют процессы, ограничивая их видимость ресурсов (PID, сеть, файловая система и т. д.).
2.    **Cgroups (Control Groups)** – ограничивают и контролируют использование ресурсов (CPU, память, дисковый I/O).
3.    **Chroot** – изолирует файловую систему, создавая "корневой" каталог для контейнера.
4.    **Capabilities** – ограничивают права процессов внутри контейнера.
5.    **Seccomp** – фильтрует системные вызовы, ограничивая доступ к API ядра.

Какие есть типы Linux Namespaces? 

**Типы Linux Namespaces**
Каждый namespace изолирует определенный ресурс:

| **Namespace** | **Изолируемый ресурс**                           | **Флаг (**clone()**)**      |
| ------------- | ------------------------------------------------ | --------------------------- |
| **PID**       | Процессы (изолирует дерево процессов)            | CLONE_NEWPID                |
| **Network**   | Сетевые интерфейсы, порты, маршруты              | CLONE_NEWNET                |
| **Mount**     | Файловые системы и точки монтирования            | CLONE_NEWNS                 |
| **UTS**       | Имя хоста и домена (hostname)                    | CLONE_NEWUTS                |
| **IPC**       | Межпроцессное взаимодействие (очереди, семафоры) | CLONE_NEWIPC                |
| **User**      | UID/GID (изолирует пользователей)                | CLONE_NEWUSER               |
| **Cgroup**    | Иерархия control groups (cgroup v2)              | CLONE_NEWCGROUP             |
| **Time**      | Системные часы (CLOCK_*)                         | CLONE_NEWTIME (с Linux 5.6) |
Как посмотреть список существующих Namespaces?

1. **Через** /proc
```
Каждый процесс привязан к своим namespaces, которые можно увидеть в /proc/<PID>/ns/:
```

```
ls -l /proc/$$/ns/  # Просмотр namespaces текущего процесса
```

Пример вывода:

lrwxrwxrwx 1 root root 0 May 13 12:00 cgroup -> 'cgroup:[4026531835]'

lrwxrwxrwx 1 root root 0 May 13 12:00 ipc -> 'ipc:[4026531839]'

lrwxrwxrwx 1 root root 0 May 13 12:00 mnt -> 'mnt:[4026531840]'

lrwxrwxrwx 1 root root 0 May 13 12:00 net -> 'net:[4026531992]'

lrwxrwxrwx 1 root root 0 May 13 12:00 pid -> 'pid:[4026531836]'

lrwxrwxrwx 1 root root 0 May 13 12:00 user -> 'user:[4026531837]'

lrwxrwxrwx 1 root root 0 May 13 12:00 uts -> 'uts:[4026531838]'

2. **Команда** lsns  
Показывает все namespaces в системе:

lsns  # Список всех namespaces

lsns -t net  # Только network namespaces

3. **Через** ip netns **(для сетевых namespaces)**

ip netns list  # Сетевые namespaces, созданные через `ip netns`

4. **Инструменты для Docker/Podman**
```
docker inspect <container> | grep -i pid  # Найти PID контейнера

ls -l /proc/<PID>/ns/  # Просмотр его namespaces
```