## Первый блок

**Multi-branch pipeline** (многовариантный пайплайн) — это тип конвейера в системах непрерывной интеграции и доставки (CI/CD), который автоматически создает и управляет отдельными ветками (branch) пайплайна для разных веток репозитория (например, в Git).
## Второй блок

Какие есть преимущества и недоставки jenkins scripted pipeline по сравнению с декларативными?   

**Сравнение Scripted и Declarative Pipeline в Jenkins**

**Преимущества Scripted Pipeline:**

1.    **Гибкость** – Полный доступ к Groovy-скриптингу, можно писать сложную логику.
2.    **Полный контроль** – Нет ограничений Declarative, можно вставлять произвольный код где угодно.
3.    **Лучше для сложных сценариев** – Если нужны динамические шаги, условные конструкции и циклы.

**Недостатки Scripted Pipeline:**

1.    **Сложность** – Требует знания Groovy, сложнее читать и поддерживать.
2.    **Меньше встроенных проверок** – Нет строгой структуры, легче допустить ошибку.
3.    **Меньше интеграции с Jenkins-экосистемой** – Некоторые плагины и фичи лучше работают с Declarative.

**Преимущества Declarative Pipeline:**

1.    **Простота** – Четкая структура (stages, steps), легче читать и писать.
2.    **Встроенные best practices** – Валидация синтаксиса, безопасность.
3.    **Лучшая интеграция с Blue Ocean и плагинами** – Удобный UI, поддержка новых фич Jenkins.

**Недостатки Declarative Pipeline:**
1.    **Менее гибкий** – Ограниченный синтаксис, сложные сценарии требуют script {} блоков.
2.    **Сложнее для нестандартных задач** – Если нужен динамический выбор шагов, Declarative может быть неудобен.

Как выбрать тот или иной стиль для своего проекта?

- **Declarative** – Подходит для большинства CI/CD-процессов (сборка, тесты, деплой).

- **Scripted** – Если нужна сложная логика (генерация шагов на лету, нестандартные условия).

---

**Что такое Jenkins Shared Library?**

Это **общий набор Groovy-скриптов**, который можно переиспользовать в разных Jenkins Pipelines. Содержит:

- **Код на Groovy** (функции, классы).
- **Глобальные переменные** (например, deployToProd()).
- **Ресурсы** (JSON, YAML-файлы).

**Пример структуры:**

shared-library/ 
├── vars/            # Глобальные переменные (напр., deploy.groovy) 
├── src/             # Groovy-классы (напр., com/utils/Logger.groovy) 
└── resources/       # Файлы конфигов (напр., config.yaml) 

---

**Как подключить Shared Library к проекту?**

**1. Настроить Shared Library в Jenkins**

- **Global:**  
Manage Jenkins → System Configuration → Global Pipeline Libraries

o    Указать репозиторий (Git, SVN).

o    Задать имя (my-shared-lib).

-  **Folder-level (если используется Folders Plugin):**  
В настройках папки добавить библиотеку.

**2. Использовать в Jenkinsfile**

**Вариант 1. Автозагрузка (если настроена Global Library)**

@Library('my-shared-lib') _  // Автозагрузка 
pipeline { 
    stages { 
        stage('Deploy') { 
            steps { 
                deployToProd()  // Функция из vars/deploy.groovy 
            } 
        } 
    } 
} 

**Вариант 2. Явное подключение**

@Library('my-shared-lib@branch-name') _  // Можно указать ветку 

**Вариант 3. Динамическая загрузка**

library('my-shared-lib@main') 

**3. Пример Shared Library**

**Файл** vars/deploy.groovy**:**

def call(String env) { 
    echo "Deploying to ${env}..." 
    sh "kubectl apply -f k8s/${env}/deployment.yaml" 
} 

**Использование в Jenkinsfile:**

deployToProd("production") 

---

**Итог**:
- **Scripted vs Declarative** – Выбор зависит от сложности логики.
- **Shared Library** – Позволяет избежать дублирования кода в Jenkinsfile.
- **Подключение** – Через @Library или настройку в Jenkins UI.
Если нужна **простота** – Declarative.  
Если нужна **гибкость** – Scripted + Shared Library.

## Третий блок

1. **Как создать свою Shared Library в Jenkins? В каких случаях это может пригодиться?**

**Создание Shared Library:**  
Shared Library в Jenkins — это репозиторий кода (обычно Groovy), который можно использовать в нескольких пайплайнах для повторного использования общих функций, шагов или логики.

**Шаги для создания:**

1.    Создайте Git-репозиторий (например, на GitHub, GitLab или Bitbucket) со структурой:

(root)
├── vars/          # Глобальные переменные и функции (доступны как `myFunction()`)
├── src/           # Классы на Groovy/Java (доступны через `import`)
└── resources/     # Внешние файлы (например, JSON, скрипты)

2.    В Jenkins:

o    **Manage Jenkins → System Configuration → Global Pipeline Libraries**

o    Укажите:
§  Имя библиотеки (my-shared-lib)
§  URL репозитория (https://github.com/your/repo.git)
§  Ветку (main, master и т. д.)
§  Опционально: Credentials, если репозиторий приватный

**Использование в Jenkinsfile:**

@Library('my-shared-lib') _  // Подключение библиотеки
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                myCustomStep()  // Функция из vars/myCustomStep.groovy
            }
        }
    }
}

**Когда это полезно:**
- **Повторное использование кода** (общие шаги для сборки, деплоя, тестирования).
- **Стандартизация** (единый подход для всех команд).
- **Упрощение поддержки** (изменения вносятся в одном месте).

---

2. **Как ограничивать доступ к проектам/джобам в Jenkins?**

В Jenkins можно настраивать права доступа через **ролевую модель (Role-Based Access Control, RBAC)**.

**Основные способы:**

1.    **Глобальные права (Manage Jenkins → Security → Manage Users/Groups)**

o    Создайте пользователей/группы (можно интегрировать с LDAP/AD).
o    Настройте глобальные права в **Manage Jenkins → Configure Global Security**.

2.    **Matrix-Based Security (или Project-based Matrix Auth Strategy)**

o    Включается в **Configure Global Security → Authorization**.

o    Позволяет тонко настраивать права для каждого пользователя/группы на уровне:
§  **Job** (сборка, настройка, удаление)
§  **Run** (отмена сборок, просмотр логов)
§  **View** (видимость определённых вьюх)

3.    **Плагины для расширенного RBAC:**

o    **Role Strategy Plugin** – позволяет создавать роли (например, Dev, QA, Admin) и назначать их пользователям.

§  **Global roles** (например, admin – полный доступ, read-only – только просмотр).

§  **Project roles** (например, dev-team – доступ только к определённым джобам по паттерну project-*).

**Пример настройки Role Strategy:**

- Создайте роль developer с правами:

o    Job/Build, Job/Read, Run/Delete

- Назначьте её пользователю user1 или группе dev-team.

---

3. **Что такое Matrix-Based Auth Strategy?**

**Matrix-Based Authorization Strategy** — это гибкий механизм управления правами в Jenkins, где можно назначать разрешения **для каждого пользователя/группы** на разных уровнях:

- **Глобальные права** (управление Jenkins, доступ к настройкам).

- **Job-уровень** (сборка, настройка, удаление).

- **Run-уровень** (просмотр логов, отмена сборок).

- **View-уровень** (создание/просмотр вьюх).

---

> [!NOTE]
> **Как это работает:**
> 
> ·         Включается в **Manage Jenkins → Configure Global Security → Authorization**.
> 
> ·         Появляется таблица (матрица), где можно выбрать права для каждого пользователя/группы.
> 
> **Пример:**
> 
> |**User/Group**|**Job/Build**|**Job/Configure**|**Job/Delete**|
> |---|---|---|---|
> |admin|✅|✅|✅|
> |developer|✅|❌|❌|
> |anonymous|❌|❌|❌|
> 
> **Плюсы:**
> 
> ·         Гибкость (можно дать разные права на разные проекты).
> ·         Не требует дополнительных плагинов.
> 
> **Минусы:**
> 
> ·         Сложно управлять при большом количестве пользователей (лучше использовать Role Strategy Plugin).

---

4. **Что такое Jenkins Sandbox?**

**Jenkins Sandbox** — это защищённая среда выполнения Groovy-скриптов, которая ограничивает доступ к потенциально опасным операциям (например, доступ к файловой системе, выполнение shell-команд).

> [!NOTE]
> [^1]**Когда используется:**
> 
> ·         При выполнении **скриптов в пайплайнах** (например, в script {}).
> 
> ·         В **Shared Libraries**, если включена проверка (Approval).
> 
> **Как работает:**
> 
> 1.    Jenkins по умолчанию запускает скрипты в Sandbox, если они не используют запрещённые методы.
> 
> 2.    Если скрипт пытается вызвать опасную операцию (например, new File("/")), требуется **ручное одобрение** админом:
> 
> o    Админ заходит в **Manage Jenkins → In-process Script Approval**.
> 
> o    Подтверждает или отклоняет запрос.
> 
> **Пример ошибки:**
> 
> groovy
> 
> Copy
> 
> Download
> 
> script {
> 
>     def file = new File("/tmp/test")  // Вызовет ошибку, пока не одобрен
> 
> }
> 
> **Как отключить Sandbox (не рекомендуется!):**
> 
> ·         В @NonCPS-функциях или при явном указании:
> 
> groovy
> 
> Copy
> 
> Download
> 
> @SuppressWarnings('GroovySandbox')
> 
> def unsafeMethod() { ... }
> 
> **Зачем нужен Sandbox?**
> 
> ·         Безопасность (предотвращает случайный или злонамеренный вред системе).
> 
> ·         Контроль над выполнением скриптов.
> 
> ---
> 
> Итог:
> 
> ·         **Shared Library** – для переиспользуемого кода в пайплайнах.
> 
> ·         **Ограничение доступа** – через Matrix/Role Strategy + плагины.
> 
> ·         **Matrix-Based Auth** – гибкие права через таблицу.
> 
> ·         **Sandbox** – защита от опасных скриптов.
> 
