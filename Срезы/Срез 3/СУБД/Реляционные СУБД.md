## Первый блок
1. **Схема в СУБД**  
Схема в системе управления базами данных (СУБД) — это логическая структура базы данных, которая определяет организацию данных, включая таблицы, их столбцы, типы данных, связи между таблицами (например, внешние ключи), а также ограничения (constraints). Схема описывает, как данные организованы и как они взаимодействуют, но не содержит самих данных. Например, в реляционной СУБД схема может включать описание таблиц, их полей и связей.

2. **Индекс в РСУБД**  
Индекс в реляционной системе управления базами данных (РСУБД) — это структура данных, которая ускоряет поиск и доступ к данным в таблице. Индексы создаются на основе одного или нескольких столбцов таблицы и позволяют СУБД быстрее выполнять запросы, такие как `SELECT`, `WHERE`, `JOIN`. Пример: индекс на столбце `user_id` ускоряет поиск записей по этому столбцу. Однако индексы увеличивают объем памяти и могут замедлять операции вставки, обновления и удаления, так как индекс тоже нужно обновлять.

3. **View в РСУБД**  
View (представление) — это виртуальная таблица, которая создается на основе результата SQL-запроса. View не хранит данные физически, а предоставляет удобный способ доступа к данным из одной или нескольких таблиц. Используется для упрощения сложных запросов, обеспечения безопасности (ограничение доступа к определенным данным) или представления данных в удобном формате. Пример:  
```sql
CREATE VIEW view_name AS
SELECT column1, column2 FROM table_name WHERE condition;
```

4. **Первичный ключ в РСУБД**  
Первичный ключ (Primary Key) — это уникальный идентификатор записи в таблице, который обеспечивает уникальность каждой строки и не может содержать NULL. Обычно это один или несколько столбцов, которые однозначно определяют запись. Например, столбец `id` с автоинкрементом часто используется как первичный ключ. Он также часто используется для связывания таблиц через внешние ключи.

5. **Транзакция в РСУБД**  
Транзакция — это последовательность операций с базой данных, которые выполняются как единое целое. Транзакции обеспечивают свойства ACID:  
- **Atomicity** (атомарность): все операции выполняются полностью или не выполняются вовсе.  
- **Consistency** (согласованность): база данных переходит из одного согласованного состояния в другое.  
- **Isolation** (изоляция): транзакции изолированы друг от друга.  
- **Durability** (долговечность): после завершения транзакции изменения сохраняются.  
Пример:  
```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
COMMIT;
```

6. **Как вывести данные определенного столбца в отсортированном по возрастанию виде (SQL)**  
Для вывода данных определенного столбца в отсортированном по возрастанию порядке используется команда `SELECT` с сортировкой через `ORDER BY`. Пример:  
```sql
SELECT column_name FROM table_name ORDER BY column_name ASC;
```  
Здесь `column_name` — имя столбца, `table_name` — имя таблицы, `ASC` — сортировка по возрастанию (по умолчанию). Например:  
```sql
SELECT first_name FROM users ORDER BY first_name ASC;
```  
Это выведет имена из таблицы `users`, отсортированные по алфавиту.
## Второй блок
1. **Почему нельзя проиндексировать все столбцы во всех таблицах в РСУБД для максимального ускорения поиска?**  
Индексирование всех столбцов во всех таблицах нецелесообразно по следующим причинам:  
- **Затраты на хранение**: Индексы занимают дополнительное место на диске. Создание индексов для каждого столбца значительно увеличивает объем базы данных.  
- **Замедление операций модификации**: При операциях `INSERT`, `UPDATE`, `DELETE` индексы нужно обновлять, что увеличивает время выполнения этих операций.  
- **Избыточность**: Не все столбцы часто используются в запросах. Индексы на редко используемых столбцах не дают прироста производительности, но увеличивают накладные расходы.  
- **Управление ресурсами**: Поддержание множества индексов требует дополнительных вычислительных ресурсов, что может снизить общую производительность СУБД.  
Оптимально создавать индексы только для столбцов, часто используемых в фильтрах (`WHERE`), сортировке (`ORDER BY`), группировке (`GROUP BY`) или соединениях (`JOIN`).  

2. **Что такое составной первичный ключ в РСУБД?**  
Составной (или композитный) первичный ключ — это первичный ключ, состоящий из двух или более столбцов, которые в комбинации обеспечивают уникальность каждой записи в таблице. Используется, когда ни один отдельный столбец не может гарантировать уникальность.  
Пример: В таблице `orders` для связи заказов и продуктов можно использовать составной ключ из столбцов `order_id` и `product_id`:  
```sql
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```  
Здесь пара `(order_id, product_id)` уникально идентифицирует каждую запись.  

3. **Что такое хранимая процедура? В чем преимущества и недостатки использования хранимых процедур?**  
**Хранимая процедура** — это набор SQL-запросов, сохраненный в базе данных под определенным именем и выполняемый как единая программа. Может принимать параметры, выполнять сложную логику и возвращать результаты.  
Пример:  
```sql
CREATE PROCEDURE GetUserById (IN userId INT)
BEGIN
    SELECT * FROM users WHERE id = userId;
END;
```  
Вызов:  
```sql
CALL GetUserById(1);
```  

**Преимущества хранимых процедур**:  
- **Производительность**: Процедуры компилируются один раз и хранятся в базе, что ускоряет выполнение по сравнению с динамическими запросами.  
- **Безопасность**: Позволяют ограничить прямой доступ к таблицам, предоставляя контролируемый интерфейс для выполнения операций.  
- **Модульность**: Упрощают повторное использование кода и централизованное управление логикой.  
- **Снижение сетевой нагрузки**: Выполняются на сервере, что уменьшает объем данных, передаваемых между клиентом и сервером.  

**Недостатки хранимых процедур**:  
- **Сложность отладки**: Отладка и тестирование процедур сложнее, чем обычных SQL-запросов.  
- **Ограниченная переносимость**: Процедуры зависят от конкретной СУБД (MySQL, PostgreSQL, SQL Server и т.д.), что затрудняет миграцию.  
- **Управление версиями**: Изменения в процедурах сложнее отслеживать и синхронизировать в системах контроля версий.  
- **Ограниченная гибкость**: Не всегда подходят для динамических запросов, где структура запроса часто меняется.  

4. **Что такое Join в SQL? Какие виды Join бывают?**  
**Join** в SQL — это операция, которая объединяет строки из двух или более таблиц на основе заданного условия (обычно по значению общего столбца). Используется для получения данных из связанных таблиц.  

**Виды Join**:  
- **INNER JOIN** (внутреннее соединение): Возвращает только строки, где есть соответствие в обеих таблицах.  
  ```sql
  SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id;
  ```  
- **LEFT JOIN** (левое внешнее соединение): Возвращает все строки из левой таблицы и соответствующие строки из правой. Если соответствия нет, возвращаются `NULL` для столбцов правой таблицы.  
  ```sql
  SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;
  ```  
- **RIGHT JOIN** (правое внешнее соединение): Возвращает все строки из правой таблицы и соответствующие строки из левой. Если соответствия нет, возвращаются `NULL` для столбцов левой таблицы.  
  ```sql
  SELECT * FROM table1 RIGHT JOIN table2 ON table1.id = table2.id;
  ```  
- **FULL JOIN** (полное внешнее соединение): Возвращает все строки из обеих таблиц, с `NULL` в местах, где нет соответствия.  
  ```sql
  SELECT * FROM table1 FULL JOIN table2 ON table1.id = table2.id;
  ```  
- **CROSS JOIN** (декартово произведение): Возвращает все возможные комбинации строк из обеих таблиц (без условия соединения).  
  ```sql
  SELECT * FROM table1 CROSS JOIN table2;
  ```  

Пример:  
Если есть таблицы `users` (id, name) и `orders` (order_id, user_id, amount), то запрос:  
```sql
SELECT users.name, orders.amount
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
```  
выведет имена всех пользователей и суммы их заказов, включая пользователей без заказов (с `NULL` в столбце `amount`).
## Третий блок
1. **Какие типы индексов бывают?**  
В реляционных СУБД существуют различные типы индексов, которые используются для оптимизации запросов. Основные типы:  
- **B-дерево (B-tree)**: Наиболее распространенный тип индекса, используется по умолчанию в большинстве СУБД (например, PostgreSQL, MySQL). Подходит для диапазонных запросов (`>`, `<`, `BETWEEN`) и точечных поисков. Основан на сбалансированном дереве.  
- **Хэш-индекс (Hash Index)**: Используется для точного соответствия (`=`). Эффективен для операций равенства, но не поддерживает диапазонные запросы. Применяется, например, в PostgreSQL.  
- **GiST (Generalized Search Tree)**: Обобщенный индекс для сложных типов данных, таких как геометрические или текстовые. Используется для поиска по пространственным данным или полнотекстового поиска (например, в PostgreSQL).  
- **GIN (Generalized Inverted Index)**: Индекс для работы с составными типами данных, такими как массивы или JSONB. Подходит для полнотекстового поиска и индексирования сложных структур.  
- **BRIN (Block Range Index)**: Индекс для больших таблиц с физически упорядоченными данными. Хранит информацию о диапазонах блоков, экономя место (используется в PostgreSQL).  
- **Bitmap Index**: Используется в некоторых СУБД (например, Oracle) для столбцов с низкой кардинальностью (мало уникальных значений). Создает битовую карту для ускорения запросов.  
- **Кластеризованный индекс (Clustered Index)**: Данные в таблице физически упорядочены по этому индексу. Обычно используется для первичного ключа (например, в SQL Server).  
- **Некластеризованный индекс (Non-clustered Index)**: Отдельная структура, содержащая указатели на данные. Позволяет хранить данные в порядке, отличном от порядка индекса.  
- **Составной индекс (Composite Index)**: Индекс на несколько столбцов, полезен для запросов, использующих комбинацию этих столбцов.  
- **Уникальный индекс (Unique Index)**: Гарантирует уникальность значений в столбце или группе столбцов.  

2. **Что такое CAP-теорема?**  
CAP-теорема (теорема Брюера) утверждает, что распределенная система может одновременно обеспечить не более двух из трех свойств:  
- **Consistency (Согласованность)**: Все узлы системы возвращают одинаковые данные в любой момент времени.  
- **Availability (Доступность)**: Система всегда отвечает на запросы, даже при сбоях.  
- **Partition Tolerance (Устойчивость к разделению)**: Система продолжает работать, даже если некоторые узлы теряют связь друг с другом.  

Согласно теореме, в распределенной системе можно гарантировать только два из этих свойств:  
- **CP-системы** (согласованность + устойчивость к разделению): Жертвуют доступностью, чтобы обеспечить согласованность данных (например, MongoDB в определенных конфигурациях).  
- **AP-системы** (доступность + устойчивость к разделению): Жертвуют согласованностью ради доступности (например, Cassandra).  
- **CA-системы**: Встречаются редко, так как распределенные системы должны быть устойчивы к разделению.  

Пример: В банковской системе важна согласованность (CP), а в системах реального времени, таких как социальные сети, приоритет может быть у доступности (AP).  

3. **Будет ли SQL-запрос, написанный для РСУБД Oracle, корректно работать в PostgreSQL? Почему?**  
SQL-запрос, написанный для Oracle, **не всегда** будет корректно работать в PostgreSQL из-за следующих причин:  
- **Различия в синтаксисе**: Хотя обе СУБД поддерживают стандарт SQL (ANSI SQL), каждая имеет свои расширения и особенности. Например:  
  - В Oracle используется `DECODE` и `NVL`, а в PostgreSQL — `COALESCE` и `CASE`.  
  - Oracle поддерживает `ROWNUM` для ограничения строк, а PostgreSQL использует `LIMIT`/`OFFSET`.  
- **Собственные функции и операторы**: Oracle имеет специфические функции (например, `TO_CHAR`, `TRUNC`), которые могут отличаться или отсутствовать в PostgreSQL.  
- **Хранимые процедуры и триггеры**: В Oracle используется PL/SQL, а в PostgreSQL — PL/pgSQL. Их синтаксис и возможности различаются.  
- **Обработка типов данных**: Типы данных и их поведение могут различаться (например, обработка `NULL` или форматы даты).  
- **Конфигурации и поведение по умолчанию**: Oracle и PostgreSQL по-разному обрабатывают транзакции, блокировки и индексы.  

Однако запросы, строго соответствующие стандарту ANSI SQL (например, простые `SELECT`, `INSERT`, `UPDATE` без специфичных функций), скорее всего, будут работать в обеих СУБД. Для переносимости рекомендуется минимизировать использование нестандартных функций и тестировать запросы.  

4. **Какие бывают уровни изоляции транзакций?**  
Уровни изоляции транзакций определяют, как транзакции взаимодействуют друг с другом и какие аномалии (например, грязное чтение) допускаются. Согласно стандарту SQL, существуют четыре уровня изоляции:  
- **Read Uncommitted (Неподтвержденное чтение)**:  
  - Транзакция может читать изменения, еще не зафиксированные другой транзакцией (грязное чтение).  
  - Самый низкий уровень изоляции, редко используется из-за риска несогласованности данных.  
  - Аномалии: грязное чтение, неповторяемое чтение, фантомы.  
- **Read Committed (Подтвержденное чтение)**:  
  - Транзакция видит только зафиксированные изменения.  
  - Устраняет грязное чтение, но допускает неповторяемое чтение и фантомы.  
  - Используется по умолчанию в большинстве СУБД (например, PostgreSQL, Oracle).  
- **Repeatable Read (Повторяемое чтение)**:  
  - Гарантирует, что данные, прочитанные в рамках одной транзакции, не изменятся другими транзакциями до ее завершения.  
  - Устраняет грязное и неповторяемое чтение, но допускает фантомы.  
  - Используется, например, в PostgreSQL для этого уровня.  
- **Serializable (Сериализуемый)**:  
  - Самый строгий уровень. Транзакции выполняются так, как если бы они шли последовательно, без параллелизма.  
  - Устраняет все аномалии (грязное чтение, неповторяемое чтение, фантомы).  
  - Может снижать производительность из-за строгих блокировок.  

**Аномалии транзакций**:  
- **Грязное чтение (Dirty Read)**: Чтение незафиксированных данных.  
- **Неповторяемое чтение (Non-repeatable Read)**: Данные, прочитанные в одной транзакции, изменяются другой транзакцией при повторном чтении.  
- **Фантомы (Phantom Read)**: Появление новых строк в результате действий другой транзакции при повторном выполнении запроса.  

Пример установки уровня изоляции в SQL:  
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```  
Разные СУБД могут реализовывать уровни изоляции по-разному (например, PostgreSQL использует MVCC для Repeatable Read и Serializable).1. **Какие типы индексов бывают?**  
В реляционных СУБД существуют различные типы индексов, которые используются для оптимизации запросов. Основные типы:  
- **B-дерево (B-tree)**: Наиболее распространенный тип индекса, используется по умолчанию в большинстве СУБД (например, PostgreSQL, MySQL). Подходит для диапазонных запросов (`>`, `<`, `BETWEEN`) и точечных поисков. Основан на сбалансированном дереве.  
- **Хэш-индекс (Hash Index)**: Используется для точного соответствия (`=`). Эффективен для операций равенства, но не поддерживает диапазонные запросы. Применяется, например, в PostgreSQL.  
- **GiST (Generalized Search Tree)**: Обобщенный индекс для сложных типов данных, таких как геометрические или текстовые. Используется для поиска по пространственным данным или полнотекстового поиска (например, в PostgreSQL).  
- **GIN (Generalized Inverted Index)**: Индекс для работы с составными типами данных, такими как массивы или JSONB. Подходит для полнотекстового поиска и индексирования сложных структур.  
- **BRIN (Block Range Index)**: Индекс для больших таблиц с физически упорядоченными данными. Хранит информацию о диапазонах блоков, экономя место (используется в PostgreSQL).  
- **Bitmap Index**: Используется в некоторых СУБД (например, Oracle) для столбцов с низкой кардинальностью (мало уникальных значений). Создает битовую карту для ускорения запросов.  
- **Кластеризованный индекс (Clustered Index)**: Данные в таблице физически упорядочены по этому индексу. Обычно используется для первичного ключа (например, в SQL Server).  
- **Некластеризованный индекс (Non-clustered Index)**: Отдельная структура, содержащая указатели на данные. Позволяет хранить данные в порядке, отличном от порядка индекса.  
- **Составной индекс (Composite Index)**: Индекс на несколько столбцов, полезен для запросов, использующих комбинацию этих столбцов.  
- **Уникальный индекс (Unique Index)**: Гарантирует уникальность значений в столбце или группе столбцов.  

2. **Что такое CAP-теорема?**  
CAP-теорема (теорема Брюера) утверждает, что распределенная система может одновременно обеспечить не более двух из трех свойств:  
- **Consistency (Согласованность)**: Все узлы системы возвращают одинаковые данные в любой момент времени.  
- **Availability (Доступность)**: Система всегда отвечает на запросы, даже при сбоях.  
- **Partition Tolerance (Устойчивость к разделению)**: Система продолжает работать, даже если некоторые узлы теряют связь друг с другом.  

Согласно теореме, в распределенной системе можно гарантировать только два из этих свойств:  
- **CP-системы** (согласованность + устойчивость к разделению): Жертвуют доступностью, чтобы обеспечить согласованность данных (например, MongoDB в определенных конфигурациях).  
- **AP-системы** (доступность + устойчивость к разделению): Жертвуют согласованностью ради доступности (например, Cassandra).  
- **CA-системы**: Встречаются редко, так как распределенные системы должны быть устойчивы к разделению.  

Пример: В банковской системе важна согласованность (CP), а в системах реального времени, таких как социальные сети, приоритет может быть у доступности (AP).  

3. **Будет ли SQL-запрос, написанный для РСУБД Oracle, корректно работать в PostgreSQL? Почему?**  
SQL-запрос, написанный для Oracle, **не всегда** будет корректно работать в PostgreSQL из-за следующих причин:  
- **Различия в синтаксисе**: Хотя обе СУБД поддерживают стандарт SQL (ANSI SQL), каждая имеет свои расширения и особенности. Например:  
  - В Oracle используется `DECODE` и `NVL`, а в PostgreSQL — `COALESCE` и `CASE`.  
  - Oracle поддерживает `ROWNUM` для ограничения строк, а PostgreSQL использует `LIMIT`/`OFFSET`.  
- **Собственные функции и операторы**: Oracle имеет специфические функции (например, `TO_CHAR`, `TRUNC`), которые могут отличаться или отсутствовать в PostgreSQL.  
- **Хранимые процедуры и триггеры**: В Oracle используется PL/SQL, а в PostgreSQL — PL/pgSQL. Их синтаксис и возможности различаются.  
- **Обработка типов данных**: Типы данных и их поведение могут различаться (например, обработка `NULL` или форматы даты).  
- **Конфигурации и поведение по умолчанию**: Oracle и PostgreSQL по-разному обрабатывают транзакции, блокировки и индексы.  

Однако запросы, строго соответствующие стандарту ANSI SQL (например, простые `SELECT`, `INSERT`, `UPDATE` без специфичных функций), скорее всего, будут работать в обеих СУБД. Для переносимости рекомендуется минимизировать использование нестандартных функций и тестировать запросы.  

4. **Какие бывают уровни изоляции транзакций?**  
Уровни изоляции транзакций определяют, как транзакции взаимодействуют друг с другом и какие аномалии (например, грязное чтение) допускаются. Согласно стандарту SQL, существуют четыре уровня изоляции:  
- **Read Uncommitted (Неподтвержденное чтение)**:  
  - Транзакция может читать изменения, еще не зафиксированные другой транзакцией (грязное чтение).  
  - Самый низкий уровень изоляции, редко используется из-за риска несогласованности данных.  
  - Аномалии: грязное чтение, неповторяемое чтение, фантомы.  
- **Read Committed (Подтвержденное чтение)**:  
  - Транзакция видит только зафиксированные изменения.  
  - Устраняет грязное чтение, но допускает неповторяемое чтение и фантомы.  
  - Используется по умолчанию в большинстве СУБД (например, PostgreSQL, Oracle).  
- **Repeatable Read (Повторяемое чтение)**:  
  - Гарантирует, что данные, прочитанные в рамках одной транзакции, не изменятся другими транзакциями до ее завершения.  
  - Устраняет грязное и неповторяемое чтение, но допускает фантомы.  
  - Используется, например, в PostgreSQL для этого уровня.  
- **Serializable (Сериализуемый)**:  
  - Самый строгий уровень. Транзакции выполняются так, как если бы они шли последовательно, без параллелизма.  
  - Устраняет все аномалии (грязное чтение, неповторяемое чтение, фантомы).  
  - Может снижать производительность из-за строгих блокировок.  

**Аномалии транзакций**:  
- **Грязное чтение (Dirty Read)**: Чтение незафиксированных данных.  
- **Неповторяемое чтение (Non-repeatable Read)**: Данные, прочитанные в одной транзакции, изменяются другой транзакцией при повторном чтении.  
- **Фантомы (Phantom Read)**: Появление новых строк в результате действий другой транзакции при повторном выполнении запроса.  

Пример установки уровня изоляции в SQL:  
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```  
Разные СУБД могут реализовывать уровни изоляции по-разному (например, PostgreSQL использует MVCC для Repeatable Read и Serializable).
